<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CTOR-DEC-2025-AI — Toroid Multi Size with AI</title>
<style>
body {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 0;
  background: #f5f5dc;
  font-family: sans-serif;
  padding: 20px;
}
#controls { margin: 20px 0; text-align: center; }
button, select {
  margin: 0 5px;
  padding: 6px 10px;
  font-size: 13px;
  cursor: pointer;
}
#gameInfo { margin: 8px 0; font-weight: bold; }
table {
  border-collapse: collapse;
  margin: 20px auto;
  cursor: pointer;
}
td {
  width: 30px;
  height: 30px;
  border: 1px solid #666;
  text-align: center;
  vertical-align: middle;
  background: #f7f3de;
  padding: 0;
  position: relative;
}
td.frame { background: #e5dfc2; }
td.inner {}

td.black::after,
td.white::after {
  content: '';
  position: absolute;
  inset: 3px;
  border-radius: 50%;
  box-shadow:
    0 1px 1px rgba(0,0,0,0.8),
    inset 0 2px 4px rgba(255,255,255,0.4),
    inset 0 -2px 4px rgba(0,0,0,0.4);
}

td.black::after {
  background: radial-gradient(circle at 30% 20%, #666, #111 70%, #000);
}

td.white::after {
  background: radial-gradient(circle at 30% 20%, #ffffff, #d0d0d0 70%, #aaaaaa);
}

td.move-source::after {
  outline: 2px solid orange;
  outline-offset: 0;
}
td.replace-selected::after {
  outline: 2px solid gold;
  outline-offset: 0;
}

.status {
  margin: 8px 0;
  padding: 8px;
  background: #e8f4fd;
  border-radius: 5px;
  font-size: 13px;
  max-width: 600px;
}
#legend {
  font-size: 12px;
  max-width: 700px;
  background: rgba(255,255,255,0.9);
  padding: 10px;
  border-radius: 6px;
}
</style>
</head>
<body>
<div id="controls">
  <label>Board size:
    <select id="sizeSelect">
      <option value="7">7 × 7</option>
      <option value="10">10 × 10</option>
      <option value="15">15 × 15</option>
      <option value="19" selected>19 × 19</option>
    </select>
  </label>
  <button id="modeBtn">Mode: <span id="modeText">Human (Black) vs AI (White)</span></button>
  <button id="endTurnBtn" disabled>End Turn</button>
  <button id="newGameBtn">New Game</button>
  <div id="gameInfo">
    Score: Black (You): <span id="score1">0</span> | White (AI): <span id="score2">0</span>
  </div>
</div>

<div id="status" class="status">
Board N×N (N = 7, 10, 15, 19), visualized with border (N+2)×(N+2). Playing against AI. You are Black.
</div>

<table id="board"></table>

<div id="legend">
<strong>Controls:</strong><br>
• <strong>Put (up to 2 times):</strong> Click on an empty inner cell.<br>
• <strong>Move (up to 2 times):</strong> Double-click on your piece → click on an empty adjacent orthogonal inner cell (considering toroid wraparound).<br>
• <strong>Replace (1 time):</strong> Ctrl+click on first piece → Ctrl+click on second piece → click on empty inner cell for the new piece.<br>
• <strong>Eating (auto, 3×3 toroid):</strong> After each action, opponent pieces with 5+ your neighbors in a 3×3 neighborhood (across borders) are automatically converted to your pieces.
</div>

<script>
class CTORMulti {
  constructor(size) {
    this.N = size;
    this.VSIZE = this.N + 2;
    this.board = [];
    this.currentPlayer = 1;
    this.mode = 'ai';
    this.opUsed = { put: 0, move: 0, replace: 0 };
    this.state = 'ready';
    this.moveFrom = null;
    this.replacePieces = [];
    this.aiThinking = false;

    this.initBoard();
    this.createTable();
    this.bindOnce();
    this.updateDisplay();
  }

  setSize(size) {
    this.N = size;
    this.VSIZE = this.N + 2;
    this.newGame();
  }

  initBoard() {
    this.board = [];
    for (let i = 0; i < this.N; i++) {
      this.board[i] = [];
      for (let j = 0; j < this.N; j++) {
        this.board[i][j] = 0;
      }
    }
  }

  buildExtendedBoard() {
    const N = this.N;
    const VS = this.VSIZE;
    const ext = [];

    for (let i = 0; i < VS; i++) {
      ext[i] = [];
      for (let j = 0; j < VS; j++) {
        ext[i][j] = 0;
      }
    }

    for (let i = 0; i < N; i++) {
      for (let j = 0; j < N; j++) {
        ext[i+1][j+1] = this.board[i][j];
      }
    }

    for (let j = 1; j <= N; j++) {
      ext[0][j]   = this.board[N-1][j-1];
      ext[N+1][j] = this.board[0][j-1];
    }

    for (let i = 1; i <= N; i++) {
      ext[i][0]   = this.board[i-1][N-1];
      ext[i][N+1] = this.board[i-1][0];
    }

    ext[0][0]       = this.board[N-1][N-1];
    ext[0][N+1]     = this.board[N-1][0];
    ext[N+1][0]     = this.board[0][N-1];
    ext[N+1][N+1]   = this.board[0][0];

    return ext;
  }

  countNeighborsWithFrame(i, j, player, ext) {
    const ei = i + 1;
    const ej = j + 1;
    let count = 0;
    for (let di = -1; di <= 1; di++) {
      for (let dj = -1; dj <= 1; dj++) {
        if (di === 0 && dj === 0) continue;
        const ni = ei + di;
        const nj = ej + dj;
        if (ext[ni][nj] === player) count++;
      }
    }
    return count;
  }

  createTable() {
    const table = document.getElementById('board');
    table.innerHTML = '';

    for (let i = 0; i < this.VSIZE; i++) {
      const tr = document.createElement('tr');
      for (let j = 0; j < this.VSIZE; j++) {
        const td = document.createElement('td');
        td.dataset.i = i;
        td.dataset.j = j;

        const isFrame = (i === 0 || j === 0 || i === this.VSIZE-1 || j === this.VSIZE-1);
        td.classList.add(isFrame ? 'frame' : 'inner');

        td.addEventListener('click', (e) => this.onCellClickVisual(i, j, e));
        td.addEventListener('dblclick', (e) => this.onCellDoubleClickVisual(i, j, e));
        tr.appendChild(td);
      }
      table.appendChild(tr);
    }
  }

  bindOnce() {
    if (!CTORMulti.bound) {
      document.getElementById('endTurnBtn').onclick = () => this.endTurn();
      document.getElementById('newGameBtn').onclick = () => this.newGame();
      document.getElementById('sizeSelect').onchange = (e) => {
        const n = parseInt(e.target.value, 10);
        this.setSize(n);
      };
      document.addEventListener('click', (e) => {
        if (!e.ctrlKey) return;
        const td = e.target.closest('td');
        if (!td) return;
        const i = parseInt(td.dataset.i, 10);
        const j = parseInt(td.dataset.j, 10);
        if (window.game) window.game.onCtrlClickVisual(i, j);
      }, { passive: true });
      CTORMulti.bound = true;
    }
  }

  visualToReal(vi, vj) {
    if (vi >= 1 && vi <= this.N && vj >= 1 && vj <= this.N) {
      return [vi - 1, vj - 1];
    }
    return null;
  }

  onCellClickVisual(vi, vj, e) {
    if (this.currentPlayer !== 1 || this.aiThinking) return;

    const real = this.visualToReal(vi, vj);
    if (!real) return;
    const [i, j] = real;

    if (this.board[i][j] !== 0) return;

    if (this.state === 'moving' && this.moveFrom) {
      const [fi, fj] = this.moveFrom;
      if (this.isOrthAdjacentToroidReal(fi, fj, i, j) && this.opUsed.move < 2) {
        this.board[fi][fj] = 0;
        this.board[i][j] = this.currentPlayer;
        this.opUsed.move++;
        this.moveFrom = null;
        this.state = 'ready';
        this.autoEat();
        this.updateDisplay();
      }
      return;
    }

    if (this.state === 'replace_place' && this.replacePieces.length === 2) {
      if (this.opUsed.replace === 0) {
        const [[i1, j1], [i2, j2]] = this.replacePieces;
        if (this.board[i1][j1] === this.currentPlayer &&
            this.board[i2][j2] === this.currentPlayer) {
          this.board[i1][j1] = 0;
          this.board[i2][j2] = 0;
          this.board[i][j] = this.currentPlayer;
          this.opUsed.replace = 1;
          this.replacePieces = [];
          this.state = 'ready';
          this.autoEat();
          this.updateDisplay();
        }
      }
      return;
    }

    if (this.state === 'ready' && this.opUsed.put < 2) {
      this.board[i][j] = this.currentPlayer;
      this.opUsed.put++;
      this.autoEat();
      this.updateDisplay();
    }
  }

  onCellDoubleClickVisual(vi, vj, e) {
    if (this.currentPlayer !== 1 || this.aiThinking) return;

    const real = this.visualToReal(vi, vj);
    if (!real) return;
    const [i, j] = real;

    if (this.state === 'ready' &&
        this.board[i][j] === this.currentPlayer &&
        this.opUsed.move < 2) {
      this.moveFrom = [i, j];
      this.state = 'moving';
      this.updateDisplay();
      this.setStatus('Piece selected for Move. Click on an empty orthogonal cell (considering toroid).');
    }
  }

  onCtrlClickVisual(vi, vj) {
    if (this.currentPlayer !== 1 || this.aiThinking) return;

    const real = this.visualToReal(vi, vj);
    if (!real) return;
    const [i, j] = real;

    if (this.board[i][j] !== this.currentPlayer) return;
    if (this.opUsed.replace > 0) return;

    if (this.replacePieces.length === 0) {
      this.replacePieces.push([i, j]);
      this.state = 'replace_select1';
      this.updateDisplay();
      this.setStatus('First piece selected for Replace. Ctrl+click on second piece.');
    } else if (this.replacePieces.length === 1) {
      const [i1, j1] = this.replacePieces[0];
      if (i1 === i && j1 === j) return;
      this.replacePieces.push([i, j]);
      this.state = 'replace_place';
      this.updateDisplay();
      this.setStatus('Two pieces selected. Click on an empty cell for the new piece.');
    }
  }

  isOrthAdjacentToroidReal(i1, j1, i2, j2) {
    const N = this.N;
    let di = Math.abs(i1 - i2);
    let dj = Math.abs(j1 - j2);
    di = Math.min(di, N - di);
    dj = Math.min(dj, N - dj);
    return (di + dj === 1);
  }

  autoEat() {
    const N = this.N;
    let changed = true;

    while (changed) {
      changed = false;
      const ext = this.buildExtendedBoard();

      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          if (this.board[i][j] === 3 - this.currentPlayer) {
            const cnt = this.countNeighborsWithFrame(i, j, this.currentPlayer, ext);
            if (cnt >= 5) {
              this.board[i][j] = this.currentPlayer;
              changed = true;
            }
          }
        }
      }
    }
  }

  aiMakeMove() {
    this.aiThinking = true;
    this.setStatus('AI is thinking...');

    setTimeout(() => {
      for (let step = 0; step < 2 && this.opUsed.put < 2; step++) {
        let bestI = -1, bestJ = -1, bestVal = -1;
        for (let i =
 0; i < this.N; i++) {
          for (let j = 0; j < this.N; j++) {
            if (this.board[i][j] === 0) {
              const val = this.aiEvaluateCell(i, j);
              if (val > bestVal) {
                bestVal = val;
                bestI = i;
                bestJ = j;
              }
            }
          }
        }
        if (bestI >= 0) {
          this.board[bestI][bestJ] = 2;
          this.opUsed.put++;
          this.autoEat();
        }
      }

      this.aiThinking = false;
      this.updateDisplay();
      
      this.currentPlayer = 2;
      setTimeout(() => this.endTurn(), 300);
    }, 800);
  }

  aiEvaluateCell(i, j) {
    let maxDist = 0;
    for (let ei = 0; ei < this.N; ei++) {
      for (let ej = 0; ej < this.N; ej++) {
        if (this.board[ei][ej] === 1) {
          let di = Math.abs(ei - i);
          let dj = Math.abs(ej - j);
          di = Math.min(di, this.N - di);
          dj = Math.min(dj, this.N - dj);
          const dist = Math.max(di, dj);
          maxDist = Math.max(maxDist, dist);
        }
      }
    }
    
    const ext = this.buildExtendedBoard();
    const ei = i + 1;
    const ej = j + 1;
    let selfNeighbors = 0;
    for (let di = -1; di <= 1; di++) {
      for (let dj = -1; dj <= 1; dj++) {
        if (di === 0 && dj === 0) continue;
        if (ext[ei + di][ej + dj] === 2) selfNeighbors++;
      }
    }
    
    return maxDist * 10 + selfNeighbors;
  }

  updateDisplay() {
    const VS = this.VSIZE;
    const tds = document.querySelectorAll('#board td');
    const ext = this.buildExtendedBoard();

    tds.forEach((td) => {
      const vi = parseInt(td.dataset.i, 10);
      const vj = parseInt(td.dataset.j, 10);

      td.classList.remove('black','white','move-source','replace-selected');

      const isFrame = (vi === 0 || vj === 0 || vi === VS-1 || vj === VS-1);
      td.classList.add(isFrame ? 'frame' : 'inner');

      const val = ext[vi][vj];
      if (val === 1) {
        td.classList.add('black');
      } else if (val === 2) {
        td.classList.add('white');
      }

      const real = this.visualToReal(vi, vj);
      if (real) {
        const [ri, rj] = real;
        if (this.moveFrom &&
            this.moveFrom[0] === ri &&
            this.moveFrom[1] === rj) {
          td.classList.add('move-source');
        }
        for (const [li, lj] of this.replacePieces) {
          if (li === ri && lj === rj) {
            td.classList.add('replace-selected');
          }
        }
      }
    });

    const [s1, s2] = this.getScore();
    document.getElementById('score1').textContent = s1;
    document.getElementById('score2').textContent = s2;

    const anyAction = (this.opUsed.put + this.opUsed.move + this.opUsed.replace) > 0;
    document.getElementById('endTurnBtn').disabled = !anyAction || this.currentPlayer !== 1;

    this.updateStatusDefault();
  }

  getScore() {
    let s1 = 0, s2 = 0;
    for (let i = 0; i < this.N; i++) {
      for (let j = 0; j < this.N; j++) {
        if (this.board[i][j] === 1) s1++;
        else if (this.board[i][j] === 2) s2++;
      }
    }
    return [s1, s2];
  }

  updateStatusDefault() {
    let base = `Board ${this.N}×${this.N} (toroid). `;
    if (this.aiThinking) {
      base += 'AI thinking...';
    } else if (this.currentPlayer === 1) {
      base += `Your turn (Black) | Put: ${2 - this.opUsed.put}  Move: ${2 - this.opUsed.move}  Replace: ${1 - this.opUsed.replace}`;
    } else {
      base += 'AI turn (White)...';
    }
    this.setStatus(base);
  }

  setStatus(text) {
    document.getElementById('status').textContent = text;
  }

  endTurn() {
    this.state = 'ready';
    this.moveFrom = null;
    this.replacePieces = [];
    this.opUsed = { put: 0, move: 0, replace: 0 };
    this.currentPlayer = 3 - this.currentPlayer;
    document.getElementById('endTurnBtn').disabled = (this.currentPlayer === 2);
    this.updateDisplay();

    if (this.currentPlayer === 2) {
      setTimeout(() => this.aiMakeMove(), 500);
    }
  }

  newGame() {
    this.initBoard();
    this.currentPlayer = 1;
    this.state = 'ready';
    this.moveFrom = null;
    this.replacePieces = [];
    this.opUsed = { put: 0, move: 0, replace: 0 };
    this.aiThinking = false;
    document.getElementById('endTurnBtn').disabled = true;
    this.createTable();
    this.updateDisplay();
    const sel = document.getElementById('sizeSelect');
    if (sel && parseInt(sel.value, 10) !== this.N) sel.value = String(this.N);
  }
}

CTORMulti.bound = false;
window.game = new CTORMulti(7);
</script>
</body>
</html>




